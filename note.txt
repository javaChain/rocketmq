源码debug:
1. 首先github下载rocketmq的4.7.1的代码
2. 配置nameserver(NamesrvController),broker(BrokerStartup)的ROCKET_HOME环境变量和
	program argument -c "E:\Program Files\rocketmq-all-4.7.1-bin-release\conf\broker.conf"
3.	依次启动namesrv/broker/producer/consumer




RouteInfoManager 收到请求之后会通过request.getCode的类型进行不同的处理!

broker 双主的时候到底是怎么处理producer发送到的消息的,如果发送到master1,master2是怎么处理的呢?

HashMap<String, List<QueueData>> topicQueueTable;
TopicQueueTable key topicName,value List<QueueData>

读队列和写队列是如何工作的?
consumer是如何定位到哪一个读队列,producer怎么选择哪一个写队列?


第二章
NameServer如何保持一致?
    1. 服务注册(broker新增): broker启动的时候会向NameServer注册自己的信息
    2. 服务剔除(broker关闭或宕机):
       - broker主动关闭 会调用方法RouteInfoManager#unregisterBroker()
       - broker宕机 NameServer每隔10S会发送心跳包给broker探活,如果120s内没有回复则剔除broker
    3. 路由发现: producer/consumer 启动会主动拉取最新的路由
NameServer相互不通信如何保证一致?
    nameserver 集群之间不需要通信,broker服务启动的时候会向每一个NameServer注册自己的信息, producer会从NameServer之中获取broker的服务器信息

nameserver 动态路由发现与剔除机制?
    ap/cp 选型 zookeeper是cp的 强一致性,那么server是ap高可用,软一致性

NameServer启动流程
NameServer启动的时候,首先加载配置文件,然后启动了2个线程池 一个10s是扫描broker,一个是10分钟打印配置文件
初始化了netty remoteServer的必要参数. 然后注册了停止函数钩子(需要借鉴). 启动remoteServer netty.服务就启动了

broker启动 加载配置文件, 初始化很多定时任务, 通过netty包装了请求向namesrv发送连接

第三章
1. 消息队列如何进行负载?
2. 消息发送如何实现高可用?
3. 批量消息发送如何实现一致?


producer发送消息基本流程:
验证消息->查找路由->消息发送
producer启动流程:
- producer.start();

    1. producer启动的时候会检查是否有producerGroup,然后把instanceName改为pid,避免同一个物理机启动2个producer无法启动
    2. 注册服务到MQClientInstance
    3. MQClientInstance启动,启动了如下的后台任务
    // Start request-response channel
    this.mQClientAPIImpl.start();
    // Start various schedule tasks
    this.startScheduledTask();
    // Start pull service
    this.pullMessageService.start();
    // Start rebalance service
    this.rebalanceService.start();
    // Start push service
    this.defaultMQProducer.getDefaultMQProducerImpl().start(false);

-  SendResult sendResult = producer.send(msg); 发送消息要先通过topic找到路由信息,然后找到对应的队列进行消息发送
查找路由信息 首先遍历broker然后遍历ConsumerQueue,所以如果是集群,查找的结构应该是:
broker-a-0,broker-a-1,broker-b-0,broker-b-1

具体如下:
this.defaultMQProducerImpl.send(msg) -> DefaultMQProducerImpl#sendDefaultImpl() ->
TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());
tryToFindTopicPublishInfo() 根据主题查找路由信息 -> 深入进去updateTopicRouteInfoFromNameServer() 从NameServer之中找到
路由信息之后,需要和本地缓存的topicRouteTable找到的TopicRouteData路由数据比较,如果数据改变了,会分别更新pub/sub的的路由信息.
topicRouteData2TopicPublishInfo(topic, topicRouteData);
for (int i = 0; i < qd.getWriteQueueNums(); i++) {
    MessageQueue mq = new MessageQueue(topic, qd.getBrokerName(), i);
    info.getMessageQueueList().add(mq);
}

 //选择一个MessageQueue
 MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
 当sendLatencyFaultEnable=true 延迟发送, 路由计算是:sendWhichQueue++%messageQueue.size()数量
 producer发送消息的时候会有故障检测,如果故障了 则会移除一段时间该broker.,移除的时间是下面计算的:
 updateFaultItem(final String brokerName, final long currentLatency, boolean isolation)里层方法
 computeNotAvailableDuration时间计算broker不参与消息发送队列负载,规避该broker.


 消息发送核心api
 - sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);
-> sendKernelImpl()这个很重要,里面封装把本地请求SendMessageRequestHeader(SendMessageRequestHeader implements CommandCustomHeader)
然后MQClientAPIImpl里面调用RemotingCommand.createRequestCommand()将SendMessageRequestHeader的请求头放入RemotingRequest,
后面会通过netty的channel.writeAndFlush(request) 进行请求发送.

上面看源码已经知道了producer发送消息到了broker,接下来我们看一下broker是如何处理的?
根据RequestCode.SEND_REPLY_MESSAGE进行匹配ReplyMessageProcessor#processRequest()
1. 首先检查消息是否合理
2. 消息重试是否达到最大重试次数,进入死信队列%DLQ%+消费组名
3. 调用PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);存储消息

RocketMQ存储核心
三大组件:
CommitLog: 存储所有topic的消息文件
ConsumerQueue: CommitLog offset,文件大小size, tag hashcode. 主要用来给消费者消费的消息队列.消息到达CommitLog文件之后,将异步转发
到消息消费队列,给消息 消费者消费.
IndexFile: hash结构,key为hashcode,value为CommitLog offset. 消息索引文件

猜测IndexFile应该是索引文件,传递key的hashcode 直接找到CommitLog的消息文件

- PutMessageResult putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);
从上面这行进行分析:













producer消息的类型:
1. 普通消息(批量)
2. 顺序消息
3. 事务消息
4. 延迟消息

broker:
1. 物理存储文件分析
2. 文件清理策略

consumer:
1. 消息重试与死信队列
2. 消费者负载与rebalance